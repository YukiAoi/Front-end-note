# 面试题

## 线上跨域

1.jsonp
2.CORS
3.proxy+nginx代理

## vuex原理

1. vuex利用vue的mixin混入机制，在beforeCreate前往store注入组件实例，并注册store的引用属性$store
2. vuex的state是响应式的，是借助了vue的data是响应式，getter则是借助了vue的computed实现数据监听

## vue-router原理

## https和http区别

1. http是明文，https有ssl加密
2. https需要证书
3. 端口不通
4. 链接方式不同，http是无状态的

## vue3 teleport

1. 瞬移组件，to属性后面是要瞬移的标签
2. disabled，禁用瞬移功能
3. 不论是否瞬移，都可以取到teleport的子组件中的数据
4. 根据teleport的顺序进行挂载
5. 原理就是将teleport中的children挂载到to的DOM中

## get和post的区别 

1. get只读，post可以修改
2. get的参数放在url中，post的放在请求体中
3. post回退时会重新请求
4. 浏览器会主动缓存get请求地址
5. get的请求参数会被保留在浏览器历史记录中
6. get的参数有长度限制

## http1和http2的区别

1. http2是二进制传输
2. 头部压缩
3. 多路复用
4. 服务器推送
5. 提高安全性(https基于http2)
6. 防止队头阻塞

## webpack打包策略：
搜索时间-缩小文件搜索范围，减少不必要的编译工作
解析时间
压缩时间
二次打包时间

开启thread-loader
防止 webpack启动慢  预热
合理使用缓存 cache-loader（保存和读取缓存文件是存在时间开销的，因此只针对相对来说大的loader） HardSourceWebpackPlugin
优化压缩时间

优化loader配置通过test,include,exclude来命中需要应用规则的文件
优化 resolve.module 配置webpack寻找第三方模块地址
优化 resolve.alias 配置别名把原本路径映射成一个新的路径，减少耗时的递归解析

## webpack原理

1. 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；
2. 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；
3. 确定入口：根据配置中的 entry 找出所有的入口文件；
4. 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
5. 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；
6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

## 从输入一个 URL 地址到浏览器完成渲染的整个过程

1. 浏览器地址栏输入 URL 并回车
2. 浏览器查找当前 URL 是否存在缓存，并比较缓存是否过期
3. DNS 解析 URL 对应的 IP
4. 根据 IP 建立 TCP 连接（三次握手）
5. 发送 http 请求
6. 服务器处理请求，浏览器接受 HTTP 响应
7. 浏览器解析并渲染页面
8. 关闭 TCP 连接（四次握手）

## webpack Plugin 和 Loader 的区别

Loader：
用于对模块源码的转换，loader 描述了 webpack 如何处理非 javascript 模块，并且在 build 中引入这些依赖。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或者将内联图像转换为 data URL。比如说：CSS-Loader，Style-Loader 等。

Plugin
目的在于解决 loader 无法实现的其他事,它直接作用于 webpack，扩展了它的功能。在 webpack 运行的生命周期中会广播出许多事件，plugin 可以监听这些事件，在合适的时机通过 webpack 提供的 API 改变输出结果。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。

